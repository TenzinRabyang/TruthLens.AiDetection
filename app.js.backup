    }

handleDragOver(e) {
    e.preventDefault();
    this.uploadZone.classList.add('drag-over');
}

handleDragLeave(e) {
    e.preventDefault();
    this.uploadZone.classList.remove('drag-over');
}

handleDrop(e) {
    e.preventDefault();
    this.uploadZone.classList.remove('drag-over');

    const files = e.dataTransfer.files;
    if (files.length > 0) {
        this.loadVideo(files[0]);
    }
}

handleFileSelect(e) {
    const files = e.target.files;
    if (files.length > 0) {
        this.loadVideo(files[0]);
    }
}

/**
 * Validate uploaded file
 * @param {File} file - File to validate
 * @returns {Object} Validation result
 */
validateFile(file) {
    // Check if file exists
    if (!file) {
        return {
            valid: false,
            error: 'No File Selected',
            details: 'Please select a video file to upload.'
        };
    }

    // Check file type
    if (!file.type.startsWith('video/')) {
        return {
            valid: false,
            error: 'Invalid File Type',
            details: `The selected file "${file.name}" is not a video file. Please upload a video in MP4, WebM, MOV, or MKV format.`
        };
    }

    // Check if format is supported
    if (!this.supportedFormats.includes(file.type)) {
        return {
            valid: false,
            error: 'Unsupported Video Format',
            details: `The video format "${file.type}" may not be supported. Recommended formats: MP4, WebM, MOV, or MKV.`
        };
    }

    // Check file size
    if (file.size > this.maxFileSize) {
        const fileSize = Utils.formatFileSize(file.size);
        const maxSize = Utils.formatFileSize(this.maxFileSize);
        return {
            valid: false,
            error: 'File Too Large',
            details: `The video file "${file.name}" is ${fileSize}, which exceeds the maximum allowed size of ${maxSize}. Please upload a smaller video file.`
        };
    }

    // Check if file is empty
    if (file.size === 0) {
        return {
            valid: false,
            error: 'Empty File',
            details: 'The selected file appears to be empty. Please select a valid video file.'
        };
    }

    return { valid: true };
}

loadVideo(file) {
    // Comprehensive file validation
    const validation = this.validateFile(file);
    if (!validation.valid) {
        this.showError(validation.error, validation.details);
        return;
    }

    try {
        // Create object URL
        const url = URL.createObjectURL(file);
        this.currentVideo = url;

        // Load video with error handling
        this.videoPlayer.src = url;
        this.videoPlayer.onerror = () => {
            this.showError(
                'Video Load Error',
                'Unable to load the video file. The file may be corrupted or in an unsupported format.'
            );
            this.reset();
        };
        this.videoPlayer.load();

        // Show video section
        this.videoSection.classList.remove('hidden');
        this.fftSection.classList.remove('hidden');
        this.resultsSection.classList.add('hidden');

        // Scroll to video
        setTimeout(() => {
            this.videoSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);

        console.log(`‚úì Loaded video: ${file.name} (${Utils.formatFileSize(file.size)})`);
    } catch (error) {
        console.error('Error loading video:', error);
        this.showError(
            'Upload Failed',
            'An unexpected error occurred while loading the video. Please try again.'
        );
    }
}

    async analyzeVideo() {
    if (!this.currentVideo) {
        this.showError(
            'No Video Loaded',
            'Please upload a video file before starting the analysis.'
        );
        return;
    }

    // Check if video is ready
    if (this.videoPlayer.readyState < 2) {
        this.showError(
            'Video Not Ready',
            'The video is still loading. Please wait a moment and try again.'
        );
        return;
    }

    // Disable button
    this.analyzeBtn.disabled = true;
    this.analyzeBtn.textContent = '‚è≥ Analyzing...';

    // Show loading overlay
    this.fftLoading.classList.remove('hidden');
    this.resultsSection.classList.add('hidden');

    try {
        // Run analysis
        const results = await this.analyzer.analyzeVideo(
            this.videoPlayer,
            (progress) => this.updateProgress(progress)
        );

        // Hide loading
        this.fftLoading.classList.add('hidden');

        // Visualize FFT
        await this.visualizer.animateIn();
        this.visualizer.render(
            results.fftData.magnitude,
            results.fftData.width,
            results.fftData.height
        );

        // Display results
        this.displayResults(results);

        // Scroll to results
        setTimeout(() => {
            this.resultsSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 500);

    } catch (error) {
        console.error('Analysis failed:', error);
        this.fftLoading.classList.add('hidden');

        // Determine error type and show appropriate message
        let errorTitle = 'Analysis Failed';
        let errorMessage = 'An error occurred during video analysis. Please try again with a different video.';

        if (error.message.includes('frame')) {
            errorTitle = 'Frame Extraction Error';
            errorMessage = 'Unable to extract frames from the video. The video may be corrupted or in an incompatible format.';
        } else if (error.message.includes('FFT')) {
            errorTitle = 'FFT Computation Error';
            errorMessage = 'An error occurred during frequency analysis. Please try a different video.';
        } else if (error.message.includes('memory')) {
            errorTitle = 'Memory Error';
            errorMessage = 'The video is too large to process. Please try a shorter or lower resolution video.';
        }

        this.showError(errorTitle, errorMessage);
    } finally {
        this.analyzeBtn.disabled = false;
        this.analyzeBtn.textContent = 'üîç Analyze Video';
    }
}

updateProgress(progress) {
    this.progressFill.style.width = `${progress}%`;
}

displayResults(results) {
    // Show results section
    this.resultsSection.classList.remove('hidden');
    this.resultsSection.classList.add('visible');

    // Set badge
    if (results.isAIGenerated) {
        this.resultBadge.textContent = '‚ö†Ô∏è AI Generated';
        this.resultBadge.className = 'result-badge ai-generated';
        this.confidenceFill.style.background = 'var(--gradient-danger)';
    } else {
        this.resultBadge.textContent = '‚úì Real Video';
        this.resultBadge.className = 'result-badge real-video';
        this.confidenceFill.style.background = 'var(--gradient-success)';
    }

    // Set confidence
    const confidence = Math.round(results.confidence);
    this.confidenceValue.textContent = `${confidence}%`;
    this.confidenceFill.style.width = `${confidence}%`;

    // Set details
    this.detectionDetails.innerHTML = '';
    results.details.forEach(detail => {
        const li = document.createElement('li');
        li.textContent = detail;
        this.detectionDetails.appendChild(li);
    });

    // Add pattern scores
    const patternsLi = document.createElement('li');
    patternsLi.innerHTML = `<strong>Pattern Analysis:</strong>`;
    this.detectionDetails.appendChild(patternsLi);

    const patternsList = document.createElement('ul');
    patternsList.style.marginLeft = '20px';
    patternsList.style.fontSize = '0.875rem';

    const patternNames = {
        gridPattern: 'Grid Pattern',
        brightDots: 'Bright Dots',
        crossShape: 'Cross Shape',
        checkerboard: 'Checkerboard',
        smoothGradient: 'Smooth Gradient'
    };

    for (const [key, value] of Object.entries(results.patterns)) {
        const li = document.createElement('li');
        const percentage = Math.round(value * 100);
        const bar = '‚ñà'.repeat(Math.floor(percentage / 10));
        li.textContent = `${patternNames[key]}: ${bar} ${percentage}%`;
        li.style.fontFamily = 'var(--font-mono)';
        li.style.color = percentage > 50 ? 'var(--color-accent-primary)' : 'var(--color-text-muted)';
        patternsList.appendChild(li);
    }

    showError(title, message) {
        // Create modal if it doesn't exist
        let modal = document.getElementById('errorModal');
        if (!modal) {
            modal = this.createErrorModal();
            document.body.appendChild(modal);
        }

        // Set content
        const modalTitle = modal.querySelector('.error-title');
        const modalMessage = modal.querySelector('.error-message');
        modalTitle.textContent = title;
        modalMessage.textContent = message;

        // Show modal
        modal.classList.add('visible');

        // Log to console
        console.error(`${title}: ${message}`);
    }

    /**
     * Create error modal element
     * @returns {HTMLElement} Modal element
     */
    createErrorModal() {
        const modal = document.createElement('div');
        modal.id = 'errorModal';
        modal.className = 'error-modal';
        modal.innerHTML = `
            <div class="error-modal-overlay"></div>
            <div class="error-modal-content">
                <div class="error-icon">‚ö†Ô∏è</div>
                <h3 class="error-title"></h3>
                <p class="error-message"></p>
                <button class="btn btn-primary error-close-btn">OK</button>
            </div>
        `;

        // Close button handler
        const closeBtn = modal.querySelector('.error-close-btn');
        const overlay = modal.querySelector('.error-modal-overlay');

        const closeModal = () => {
            modal.classList.remove('visible');
        };

        closeBtn.addEventListener('click', closeModal);
        overlay.addEventListener('click', closeModal);

        return modal;
    }
}

// Initialize app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.app = new AIVideoDetectionApp();
    console.log('AI Video Detection App initialized');
});
